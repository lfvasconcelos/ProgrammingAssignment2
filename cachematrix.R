## NOTE: As English is not my native language, I apologize for any
##   grammatical errors

####

## Caching the inverse of a matrix, rather than compute it repeatedly,
##   can avoid computation consuming tasks and save time.
## The two functions below are used together to create a special "matrix"
##   object and to calculate and cache its inverse

####

# The 'makeCacheMatrix' function creates a special "matrix", which is really
#   a list containing a function to:
#     1. set the value of the matrix
#     2. get the value of the matrix
#     3. set the value of the inverse of the matrix
#     4. get the value of the inverse of the matrix

makeCacheMatrix <- function(x = matrix()) { # Input 'x' will be a matrix
    
    i <- NULL   # 'i' will store the 'inverse' of the matrix and it's
                #   reset to NULL every time 'makeCacheMatrix' is called
    
    set <- function(y) {    # Takes an input matrix (NOTE: this function is not
                            #   essential, but was kept to maintain consistency
                            #   with the original example)
        
        x <<- y     # Saves the input matrix in 'x' of the parent function
        
        i <<- NULL  # Resets 'i' of the parent function to NULL, when the new
                    #   object is generated by 'set'
    }
    
    get <- function() x     # This function returns the value of the matrix
    
    setinv <- function(inv) i <<- inv   # This is called by cacheSolve() if the
                                        #   inverse has not been cached yet and
                                        #   saves the inverse in 'i' of the
                                        #   parent function
    
    getinv <- function() i  # This will return the cached value to cacheSolve()
                            #   on subsequent accesses
    
    list(set = set, get = get,  # This list is returned with the newly created
         setinv = setinv,       #   object. It lists all the functions
         getinv = getinv)       #   ("methods") that are part of the object.
}

####

# The 'cacheSolve' function checks to see if the inverse of the matrix
#   has already been calculated. If so, it gets the inverse from the cache
#   and skips the computation. Otherwise, it calculates the inverse of the
#   matrix created by 'makeCacheMatrix' and sets the value of the inverse
#   in the cache via the 'setinv' function

cacheSolve <- function(x, ...) {    # The input is an object created by
                                    #   'makeCacheMatrix'
    
    i <- x$getinv() # Accesses the object 'x' and gets the inverse
    
    if(!is.null(i)) {   # If the inverse was already cached (not NULL)
        
        message("getting cached data")  # Then send this message to the console
        
        return(i)   # And return the inverse. 'return' ends the function
                    #  cacheSolve()
    }
    data <- x$get() # If 'x$getinv()' return NULL, then 'cacheSolve()' continues
                    #   and saves the object created by 'makeCacheMatrix'
    
    i <- solve(data, ...)    # Calculate the inverse of the matrix
    
    x$setinv(i) # Store the calculated inverse in the object 'x'
    
    i   # Return the 'i' to the code that called this function
}